{
  "main": {
    "scope": "cpp",
    "prefix": "cpp-cp",
    "body": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "",
      "#define int long long",
      "#define fastio ios_base::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL)",
      "#define endl '\\n'",
      "#define debug(x) cout << #x << \" => \" << (x) << endl",
      "",
      "template <typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& _p) { ",
      "  os << \"(\" << _p.first << \", \" << _p.second << \")\"; return os; ",
      "}",
      "template <typename T> istream& operator>>(istream& is, vector<T>& _v) {",
      "  for (auto& _x : _v) { is >> _x; } return is;",
      "}",
      "template <typename Ch, typename Tr, typename Container>",
      "basic_ostream<Ch, Tr>& operator<<(basic_ostream<Ch, Tr>& os, const Container& _c) {",
      "  size_t _i = 0; os << \"{ \"; for (const auto& _x : _c) { os << (_i++ ? \", \" : \"\") << _x; }",
      "  return os << \" }\";",
      "}",
      "inline void print() { cout << endl; }",
      "template <typename T = const char*, typename... U> ",
      "inline void prin(T&& A = \"\", U&&... B) { cout << A; if (sizeof...(U)) prin(B...); }",
      "template <typename T, typename... U>",
      "inline void print(T&& A, U&&... B) { prin(A); if (sizeof...(U)) prin(' '); print(B...); }",
      "template <typename T> inline void prinsp(T&& A, char sp = ' ') { prin(A, sp); }",
      "",
      "template <typename T> using vec = vector<T>;",
      "template <typename T> struct vvec : vec<vec<T>> {",
      "  using vec<vec<T>>::vec;",
      "  vvec(size_t N = 0, size_t M = 0, const T& _init_value = T())",
      "    : vec<vec<T>>(N, vec<T>(M, _init_value)) {}",
      "};",
      "template <typename T> struct vvvec : vec<vvec<T>> {",
      "  using vec<vvec<T>>::vec;",
      "  vvvec(size_t N = 0, size_t M = 0, size_t K = 0, const T& _init_value = T())",
      "    : vec<vvec<T>>(N, vvec<T>(M, K, _init_value)) {}",
      "};",
      "",
      "using pii = pair<int, int>;",
      "using iii = tuple<int, int, int>;",
      "#define fi first",
      "#define se second",
      "#define eb emplace_back",
      "#define all(x) (x).begin(), (x).end()",
      "#define len(x) (int)(x).size()",
      "",
      "const int MOD = 1e9 + 7; // 998244353;",
      "const int INF = 2e9;",
      "const double EPS = 1e-9;",
      "",
      "void solve() {",
      "  $0",
      "}",
      "",
      "signed main() {",
      "  fastio;",
      "  // cout << fixed << setprecision(6);",
      "",
      "  // precompute();",
      "  // int t; cin >> t; while(t--)",
      "  solve();",
      "}",
    ],
    "description": "Default cpp code for Competitive Programming"
  },
  "test-case": {
    "prefix": "tc",
    "scope": "cpp",
    "body": [
      "int t; cin >> t; for(int tc = 1; tc <= t; tc++)",
      "prin(\"Case #\", tc, \": \"),"
    ],
    "description": "Test Case"
  },
  "pbds": {
    "scope": "cpp",
    "prefix": "pbds",
    "body": [
      "#include <ext/pb_ds/assoc_container.hpp>",
      "#include <ext/pb_ds/tree_policy.hpp>",
      "using namespace __gnu_pbds;",
      "template <typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;"
    ],
    "description": "PBDS cpp code"
  },
  "Static Mod Int": {
    "prefix": "modint",
    "scope": "cpp",
    "body": [
      "template<int M>",
      "struct ModInt {",
      "  int val;",
      "  ModInt(int v = 0) : val(v) { if(val < 0 || val >= M) val %= M; if(val < 0) val += M; }",
      "  explicit operator int() const { return val; }",
      "",
      "  ModInt& operator+=(const ModInt& other) { return (val += other.val) >= M ? val -= M : val, *this; }",
      "  ModInt& operator-=(const ModInt& other) { return (val -= other.val) < 0 ? val += M : val, *this; }",
      "  ModInt& operator*=(const ModInt& other) { return (val *= other.val) %= M, *this; }",
      "  ModInt& operator/=(const ModInt& other) { return *this *= inv(other.val); }",
      "  ModInt& operator++() { return *this += 1; }",
      "  ModInt& operator--() { return *this -= 1; }",
      "  ModInt operator++(int32_t) { ModInt mi = *this; ++*this; return mi; }",
      "  ModInt operator--(int32_t) { ModInt mi = *this; --*this; return mi; }",
      "  ModInt operator+() const { return *this; }",
      "  ModInt operator-() const { return ModInt() -= *this; }",
      "  friend ModInt operator+(const ModInt& lhs, const ModInt& rhs) { return ModInt(lhs) += rhs; }",
      "  friend ModInt operator-(const ModInt& lhs, const ModInt& rhs) { return ModInt(lhs) -= rhs; }",
      "  friend ModInt operator*(const ModInt& lhs, const ModInt& rhs) { return ModInt(lhs) *= rhs; }",
      "  friend ModInt operator/(const ModInt& lhs, const ModInt& rhs) { return ModInt(lhs) /= rhs; }",
      "",
      "  friend ModInt pow(ModInt mi, int k) { ModInt r = 1; for(; k > 0; k /= 2, mi *= mi) if(k & 1) r *= mi; return r; }",
      "  static int inv(int mi, int mod) { return mi == 1 ? 1 : mod - inv(mod % mi, mi) * mod / mi; }",
      "  static int inv(ModInt mi) {",
      "    return (int) pow(mi, M - 2);",
      "    // if(gcd(mi.val, M) != 1) return -1;",
      "    return inv(mi.val, M); // use this inv if M is not prime",
      "  }",
      "",
      "  bool operator==(const ModInt& other) const { return val == other.val; }",
      "  bool operator!=(const ModInt& other) const { return val != other.val; }",
      "  friend istream& operator>>(istream& is, ModInt& mi) { is >> mi.val; mi = ModInt(mi.val); return is; }",
      "  friend ostream& operator<<(ostream& os, const ModInt& mi) { return os << mi.val; }",
      "};",
      "",
      "using mint = ModInt<1000000007>;",
      "// using mint = ModInt<998244353>;"
    ],
    "description": "Static Mod Int with fixed modulus"
  },
  "Dynamic Mod Int": {
    "prefix": "modintdyn",
    "scope": "cpp",
    "body": [
      "struct ModInt {",
      "  using u128 = __uint128_t;",
      "  static inline uint64_t mod, mu;",
      "  uint64_t val;",
      "",
      "  ModInt() : val(0) {}",
      "  ModInt(int v) { if (v < 0) (v %= (int)mod) += mod; val = reduce(v); }",
      "  explicit operator int() const { return val; }",
      "  static void set_mod(int m) { mod = m, mu = -1ULL / m; }",
      "  static inline uint64_t reduce(u128 x) {",
      "    u128 q = (x * mu) >> 64;",
      "    u128 r = x - q * mod;",
      "    return r >= mod ? r - mod : r;",
      "  }",
      "",
      "  ModInt& operator+=(const ModInt& other) { return (val += other.val) >= mod ? val -= mod : val, *this; }",
      "  ModInt& operator-=(const ModInt& other) { return (val -= other.val) >= mod ? val += mod : val, *this; }",
      "  ModInt& operator*=(const ModInt& other) { return val = reduce(u128(val) * other.val), *this; }",
      "  ModInt& operator/=(const ModInt& other) { return *this *= inv(other.val); }",
      "  ModInt& operator++() { return *this += 1; }",
      "  ModInt& operator--() { return *this -= 1; }",
      "  ModInt operator++(int32_t) { ModInt mi = *this; ++*this; return mi; }",
      "  ModInt operator--(int32_t) { ModInt mi = *this; --*this; return mi; }",
      "  ModInt operator+() const { return *this; }",
      "  ModInt operator-() const { return ModInt() -= *this; }",
      "  friend ModInt operator+(const ModInt& lhs, const ModInt& rhs) { return ModInt(lhs) += rhs; }",
      "  friend ModInt operator-(const ModInt& lhs, const ModInt& rhs) { return ModInt(lhs) -= rhs; }",
      "  friend ModInt operator*(const ModInt& lhs, const ModInt& rhs) { return ModInt(lhs) *= rhs; }",
      "  friend ModInt operator/(const ModInt& lhs, const ModInt& rhs) { return ModInt(lhs) /= rhs; }",
      "",
      "  friend ModInt pow(ModInt mi, int k) { ModInt r = 1; for(; k > 0; k /= 2, mi *= mi) if(k & 1) r *= mi; return r; }",
      "  static int inv(int mi, int mod) { return mi == 1 ? 1 : mod - inv(mod % mi, mi) * mod / mi; }",
      "  static int inv(ModInt mi) { ",
      "    return (int) pow(mi, mod - 2);",
      "    // if(gcd(mi.val, mod) != 1) return -1;",
      "    return inv(mi.val, mod); // use this inv if mod is not prime",
      "  }",
      "",
      "  bool operator==(const ModInt& other) const { return val == other.val; }",
      "  bool operator!=(const ModInt& other) const { return val != other.val; }",
      "  friend istream& operator>>(istream& is, ModInt& mi) { is >> mi.val; mi = ModInt(mi.val); return is; }",
      "  friend ostream& operator<<(ostream& os, const ModInt& mi) { return os << mi.val; }",
      "};",
      "",
      "using mint = ModInt;"
    ],
    "description": "Dynamic Mod Int with input modulus"
  },
  "factorial": {
    "prefix": "factorial",
    "body": [
      "const int MAXN = 1e6;",
      "mint fact[MAXN + 1];",
      "",
      "void precompute() {",
      "  fact[0] = 1;",
      "  for(int i = 1; i <= MAXN; i++) fact[i] = fact[i - 1] * i;",
      "}",
      "",
      "mint C(int n, int k) {",
      "  if(k > n) return 0;",
      "  return fact[n] / (fact[k] * fact[n - k]);",
      "}",
    ],
    "description": "Factorial Precomputation"
  },
  "directions": {
    "scope": "cpp",
    "prefix": "directions",
    "body": [
      "vec<pii> dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}, {1, 1}, {1, -1}, {-1, 1}, {-1, -1}};",
    ],
    "description": "8 directions"
  },
  "Print Vector": {
    "prefix": "printv",
    "scope": "cpp",
    "body": [
      "for(auto &x : ${0:ans}) prin(x, \" \\n\"[&x == &${0:ans}.back()]);"
    ],
    "description": "Print Vector"
  },
  "DSU": {
    "scope": "cpp",
    "prefix": "dsu",
    "body": [
      "struct DSU {",
      "\tvec<int> parent, sizes;",
      "\tDSU(int n) : parent(n), sizes(n, 1) {",
      "\t\tiota(all(parent), 0);",
      "\t}",
      "",
      "\tint find(int u) {",
      "\t\treturn u == parent[u] ? u : parent[u] = find(parent[u]);",
      "\t}",
      "",
      "\tbool unite(int u, int v) {",
      "\t\tu = find(u), v = find(v);",
      "\t\tif(u == v) return false;",
      "\t\t",
      "\t\tif(sizes[u] < sizes[v]) swap(u, v);",
      "\t\tsizes[u] += sizes[v];",
      "\t\tparent[v] = u;",
      "\t\treturn true;",
      "\t}",
      "};"
    ],
    "description": "DSU"
  },
  "Sparse Table": {
    "scope": "cpp",
    "prefix": "sparsetable",
    "body": [
      "struct SparseTable {",
      "  int n;",
      "  vec<int> lg;",
      "  vvec<int> table;",
      "",
      "  SparseTable() {}",
      "  SparseTable(const vec<int>& v) : n(len(v)) {",
      "    lg.resize(n + 1);",
      "    lg[1] = 0;",
      "    for(int i = 2; i <= n; i++) lg[i] = lg[i / 2] + 1;",
      "",
      "    table.resize(lg[n] + 1, vec<int>(n));",
      "    for(int i = 0; i < n; i++) table[0][i] = v[i];",
      "    for(int k = 1; k <= lg[n]; k++) {",
      "      for(int i = 0; i + (1 << k) <= n; i++) {",
      "        table[k][i] = merge(table[k - 1][i], table[k - 1][i + (1 << (k - 1))]);",
      "      }",
      "    }",
      "  }",
      "",
      "  int merge(int left, int right) {",
      "    return min(left, right);",
      "  }",
      "",
      "  int query(int l, int r) {",
      "    // l--, r--;",
      "    int k = lg[r - l + 1];",
      "    return merge(table[k][l], table[k][r - (1 << k) + 1]);",
      "",
      "    int res = INF;",
      "    for(; k >= 0; k--) {",
      "      if((1 << k) <= r - l + 1) {",
      "        res = merge(res, table[k][l]);",
      "        l += 1 << k;",
      "      }",
      "    }",
      "",
      "    return res;",
      "  }",
      "};"
    ],
    "description": "Sparse Table Implementation"
  },
  "Fenwick Tree": {
    "scope": "cpp",
    "prefix": "fenwicktree",
    "body": [
      "struct FenwickTree {",
      "  int n;",
      "  vec<int> bit;",
      "",
      "  FenwickTree(int _n) : n(_n + 1) {",
      "    bit.resize(n);",
      "  }",
      "",
      "  FenwickTree(const vec<int>& v) : FenwickTree(len(v)) {",
      "    for(int i = 0; i < len(v); i++)",
      "      update(i, v[i]);",
      "  }",
      "",
      "  void update(int pos, int val) {",
      "    for(++pos; pos < n; pos += pos & -pos) ",
      "      bit[pos] += val;",
      "  }",
      "",
      "  int query(int pos) {",
      "    int res = 0;",
      "    for(++pos; pos > 0; pos -= pos & -pos)",
      "      res += bit[pos];",
      "    return res;",
      "  }",
      "",
      "  int query(int l, int r) {",
      "    return query(r) - query(l - 1);",
      "  }",
      "};"
    ],
    "description": "Fenwick Tree Implementation"
  },
  "Segment Tree": {
    "scope": "cpp",
    "prefix": "segtree",
    "body": [
      "struct SegmentTree {",
      "  struct node {",
      "    int val;",
      "    node(int v = ${1:0}) : val(v) {}",
      "",
      "    friend node merge(const node& left, const node& right) {",
      "      node res;",
      "      res.val = left.val + right.val;",
      "      return res;",
      "    }",
      "  };",
      "",
      "  int n;",
      "  vec<node> tree;",
      "",
      "  SegmentTree(int _n) : n(_n) {",
      "    tree.resize(n << 1);",
      "  }",
      "",
      "  SegmentTree(const vec<int>& v) : SegmentTree(len(v)) {",
      "    for(int i = 0; i < n; i++) tree[i + n] = node(v[i]);",
      "    for(int id = n - 1; id; id--) pull(id);",
      "  }",
      "",
      "  void pull(int id) {",
      "    tree[id] = merge(tree[id << 1], tree[id << 1 | 1]);",
      "  }",
      "",
      "  void update(int id, int value) {",
      "    // --id;",
      "    id += n;",
      "",
      "    tree[id].val = value;",
      "    for(id >>= 1; id; id >>= 1) pull(id);",
      "  }",
      "",
      "  int query(int id) {",
      "    // --id;",
      "    id += n;",
      "",
      "    return tree[id].val;",
      "  }",
      "",
      "  int query(int l, int r) {",
      "    // --l, --r;",
      "    ",
      "    node resL, resR;",
      "    for(l += n, r += n + 1; l < r; l >>= 1, r >>= 1) {",
      "      if(l & 1) resL = merge(resL, tree[l++]);",
      "      if(r & 1) resR = merge(tree[--r], resR);",
      "    }",
      "",
      "    return merge(resL, resR).val;",
      "  }",
      "};"
    ],
    "description": "Segment Tree Implementation"
  },
  "Lazy Segment Tree": {
    "scope": "cpp",
    "prefix": "segtreelazy",
    "body": [
      "struct SegmentTree {",
      "  struct node {",
      "    int val;",
      "    node(int v = ${1:0}) : val(v) {}",
      "",
      "    friend node merge(const node& left, const node& right) {",
      "      node res;",
      "      res.val = left.val + right.val;",
      "      return res;",
      "    }",
      "  };",
      "",
      "  struct tag {",
      "    int val;",
      "",
      "    tag() : val(0) {}",
      "    tag(int v) : val(v) {}",
      "  };",
      "",
      "  int n, h;",
      "  vec<node> tree;",
      "  vec<tag> lazy;",
      "",
      "  SegmentTree(int _n) : n(_n), h(0) {",
      "    for(; 1 << h < n; h++);",
      "    tree.resize(n << 1);",
      "    lazy.resize(n);",
      "  }",
      "",
      "  SegmentTree(const vec<int>& v) : SegmentTree(len(v)) {",
      "    for(int i = 0; i < n; i++) tree[i + n] = node(v[i]);",
      "    for(int id = n - 1; id; id--) pull(id);",
      "  }",
      "",
      "  void apply(int id, int k, tag t) {",
      "    if(t.val != 0) {",
      "      tree[id].val += k * t.val;",
      "      if(id < n) lazy[id].val += t.val;",
      "    }",
      "  }",
      "",
      "  void push(int id, int k) {",
      "    apply(id << 1, k, lazy[id]);",
      "    apply(id << 1 | 1, k, lazy[id]);",
      "    lazy[id] = tag();",
      "  }",
      "",
      "  void pull(int id) {",
      "    tree[id] = merge(tree[id << 1], tree[id << 1 | 1]);",
      "  }",
      "",
      "  void update(int l, int r, int value) {",
      "    // --l, --r;",
      "    l += n, r += n + 1;",
      "",
      "    for(int i = h; i; i--) {",
      "      if(l >> i << i != l) push(l >> i, 1 << (i - 1));",
      "      if(r >> i << i != r) push((r - 1) >> i, 1 << (i - 1));",
      "    }",
      "",
      "    for(int le = l, ri = r, k = 1; le < ri; le >>= 1, ri >>= 1, k <<= 1) {",
      "      if(le & 1) apply(le++, k, tag(value));",
      "      if(ri & 1) apply(--ri, k, tag(value));",
      "    }",
      "",
      "    for(int i = 1; i <= h; i++) {",
      "      if(l >> i << i != l) pull(l >> i);",
      "      if(r >> i << i != r) pull((r - 1) >> i);",
      "    }",
      "  }",
      "",
      "  int query(int id) {",
      "    // --id;",
      "    id += n;",
      "",
      "    for(int i = h; i; i--) push(id >> i, 1 << (i - 1));",
      "    return tree[id].val;",
      "  }",
      "",
      "  int query(int l, int r) {",
      "    // --l, --r;",
      "    l += n, r += n + 1;",
      "",
      "    for(int i = h; i; i--) {",
      "      if(l >> i << i != l) push(l >> i, 1 << (i - 1));",
      "      if(r >> i << i != r) push((r - 1) >> i, 1 << (i - 1));",
      "    }",
      "",
      "    node resL, resR;",
      "    for(; l < r; l >>= 1, r >>= 1) {",
      "      if(l & 1) resL = merge(resL, tree[l++]);",
      "      if(r & 1) resR = merge(tree[--r], resR);",
      "    }",
      "",
      "    return merge(resL, resR).val;",
      "  }",
      "};"
    ],
    "description": "Lazy Segment Tree Implementation"
  },
  "Line Intersection": {
    "prefix": "inter",
    "scope": "cpp",
    "body": [
      "struct point {",
      "  int x, y;",
      "  point(int _x = 0, int _y = 0) : x(_x), y(_y) {}",
      "  point operator+(const point& p) const { return point(x + p.x, y + p.y); }",
      "  point operator-(const point& p) const { return point(x - p.x, y - p.y); }",
      "  ",
      "  int cross(const point& p) const { return x * p.y - y * p.x; }",
      "  int cross(const point& p, const point& q) const { return (p - *this).cross(q - *this); }",
      "  double dist(const point& p) const { return sqrt((x - p.x) * (x - p.x) + (y - p.y) * (y - p.y)); }",
      "",
      "  friend bool intersect(point p, point q, point r, point s) {",
      "    auto sign = [](int x) { return x >= 0 ? x > 0 : -1; };",
      "    auto overlap = [](int a, int b, int c, int d) {",
      "      return max(min(a, b), min(c, d)) <= min(max(a, b), max(c, d));",
      "    };",
      "",
      "    if(sign(p.cross(r, s)) == 0 && sign(r.cross(p, q)) == 0)",
      "      return overlap(p.x, q.x, r.x, s.x) && overlap(p.y, q.y, r.y, s.y);",
      "",
      "    return sign(p.cross(r, s)) != sign(q.cross(r, s)) && sign(r.cross(p, q)) != sign(s.cross(p, q));",
      "  }",
      "",
      "  bool operator==(const point& p) const { return x == p.x && y == p.y; }",
      "  bool operator!=(const point& p) const { return x != p.x || y != p.y; }",
      "  friend istream& operator>>(istream& is, point& p) { return is >> p.x >> p.y; }",
      "  friend ostream& operator<<(ostream& os, const point& p) { return os << p.x << ' ' << p.y << endl; }",
      "};"
    ],
    "description": "Line Intersection"
  },
  "Matrix Eksponensial": {
    "prefix": "matrix",
    "scope": "cpp",
    "body": [
      "struct matrix : vvec<mint> {",
      "  using vvec<mint>::vvec;",
      "",
      "  matrix& operator*=(const matrix& other) {",
      "    int n = len((*this));",
      "    int m = len((*this)[0]);",
      "    assert(m == len(other));",
      "",
      "    matrix res(n, m);",
      "    for(int i = 0; i < n; i++)",
      "      for(int j = 0; j < len(other[0]); j++)",
      "        for(int k = 0; k < m; k++)",
      "          res[i][j] += (*this)[i][k] * other[k][j];",
      "    return *this = res;",
      "  }",
      "",
      "  matrix operator*(const matrix& other) const { ",
      "    return matrix(*this) *= other; ",
      "  }",
      "",
      " friend matrix pow(matrix mat, int k) {",
      "    int n = len(mat);",
      "    assert(n == len(mat[0]));",
      "",
      "    matrix res(n, n);",
      "    for(int i = 0; i < n; i++) res[i][i] = 1;",
      "    for(; k > 0; k /= 2, mat *= mat) if(k & 1) res *= mat;",
      "    return res;",
      "  }",
      "};"
    ],
    "description": "Matrix Eksponensial"
  },
  "Sieve of Eratosthenes": {
    "prefix": "sieve",
    "scope": "cpp",
    "body": [
      "const int MAXN = 2e5;",
      "bool isPrime[MAXN + 1];",
      "vec<int> primes;",
      "",
      "void precompute() {",
      "  memset(isPrime, true, sizeof(isPrime));",
      "  isPrime[0] = isPrime[1] = false;",
      "  for(int i = 2; i <= MAXN; i++) {",
      "    if(isPrime[i]) {",
      "      primes.eb(i);",
      "      for(int j = i * i; j <= MAXN; j += i) {",
      "        isPrime[j] = false;",
      "      }",
      "    }",
      "  }",
      "}"
    ],
    "description": "Sieve of Eratosthenes Precomputation"
  },
  "Small Prime Factor": {
    "prefix": "spf",
    "scope": "cpp",
    "body": [
      "const int MAXN = 2e5;",
      "int spf[MAXN + 1];",
      "",
      "void precompute() {",
      "  iota(spf, spf + MAXN + 1, 0);",
      "  for(int i = 2; i * i <= MAXN; i++) {",
      "    if(spf[i] == i) {",
      "      for(int j = i * i; j <= MAXN; j += i) {",
      "        if(spf[j] == j) spf[j] = i;",
      "      }",
      "    }",
      "  }",
      "}"
    ],
    "description": "Small Prime Factor Precomputation"
  },
  "Implicit Treap": {
    "prefix": "treap",
    "scope": "cpp",
    "body": [
      "template <typename T> ",
      "struct treap {",
      "  struct node;",
      "  using pnode = node*;",
      "  pnode root;",
      "  ",
      "  struct node {",
      "    T val;",
      "    int prior, size;",
      "    pnode l, r;",
      "    bool rev;",
      "    node(const T& v) : val(v), prior(rand()), size(1), l(NULL), r(NULL), rev(false) {}",
      "  };",
      "",
      "  treap() : root(NULL) {}",
      "",
      "  int size(pnode t) { return t ? t->size : 0; }",
      "",
      "  void push(pnode t) {",
      "    if(!t) return;",
      "",
      "    if(t->rev) {",
      "      swap(t->l, t->r);",
      "",
      "      if(t->l) t->l->rev ^= 1;",
      "      if(t->r) t->r->rev ^= 1;",
      "",
      "      t->rev = false;",
      "    }",
      "  }",
      "",
      "  void pull(pnode t) {",
      "    if(!t) return;",
      "",
      "    t->size = 1 + size(t->l) + size(t->r);",
      "  }",
      "",
      "  void split(pnode t, pnode &a, pnode &b, int pos) {",
      "    if(!t) return void(a = b = NULL);",
      "",
      "    push(t);",
      "",
      "    if(size(t->l) < pos) ",
      "      split(t->r, t->r, b, pos - size(t->l) - 1), a = t;",
      "    else ",
      "      split(t->l, a, t->l, pos), b = t;",
      "",
      "    pull(t);",
      "  }",
      " ",
      "  void merge(pnode &t, pnode a, pnode b) {",
      "    push(a), push(b);",
      "",
      "    if(!a || !b) ",
      "      t = a ? a : b;",
      "    else if(a->prior < b->prior) ",
      "      merge(a->r, a->r, b), t = a;",
      "    else",
      "      merge(b->l, a, b->l), t = b;",
      "",
      "    pull(t);",
      "  }",
      "",
      "  T at(pnode t, int index) {",
      "    push(t);",
      "",
      "    if(index < size(t->l))",
      "      return at(t->l, index);",
      "    if(index > size(t->l))",
      "      return at(t->r, index - size(t->l) - 1);",
      "",
      "    return t->val;",
      "  }",
      "",
      "  T operator[](int index) {",
      "    assert(index >= 0 && index < size(root));",
      "    return at(root, index);",
      "  }",
      " ",
      "  int size() { return size(root); }",
      "  ",
      "  void insert(const T& val) {",
      "    merge(root, root, new node(val));",
      "  }",
      "",
      "  void insert_at(int index, const T& val) {",
      "    assert(index >= 0 && index <= size());",
      "",
      "    pnode a, b;",
      "    split(root, a, b, index);",
      "    merge(a, a, new node(val));",
      "    merge(root, a, b);",
      "  }",
      " ",
      "  void erase_at(int index) {",
      "    assert(index >= 0 && index < size());",
      "",
      "    pnode a, b, c;",
      "    split(root, a, b, index);",
      "    split(b, b, c, 1);",
      "    merge(root, a, c);",
      "  }",
      "",
      "  void clear() {",
      "    root = NULL;",
      "  }",
      "",
      "  void update(int l, int r) {",
      "    // l--, r--;",
      "",
      "    pnode a, b, c;",
      "    split(root, a, b, l);",
      "    split(b, b, c, r - l + 1);",
      "",
      "    b->rev = true;",
      "",
      "    merge(root, a, b);",
      "    merge(root, root, c);",
      "  }",
      "",
      "  T query(int l, int r) {",
      "",
      "  }",
      "};"
    ],
    "description": "Treap Data Structure",
  },
  "KMP": {
    "prefix": "kmp",
    "scope": "cpp",
    "body": [
      "struct KMP {",
      "  int m;  ",
      "  string pat;",
      "  vec<int> pi;",
      "",
      "  KMP(const string& s) : m(len(s)), pat(s) {",
      "    pi.resize(m);",
      " ",
      "    for(int i = 1, j = 0; i < m; i++) {",
      "      for(; j > 0 && s[i] != s[j]; j = pi[j - 1]); ",
      "      if(s[i] == s[j]) j++;",
      "      pi[i] = j;",
      "    }",
      "  }",
      "",
      "  vec<int> match(const string& text) {",
      "    vec<int> res;",
      "    for(int i = 0, j = 0; i < len(text); i++) {",
      "      for(; j > 0 && text[i] != pat[j]; j = pi[j - 1]);",
      "      if(text[i] == pat[j]) j++;",
      "      if(j == m) res.eb(i - m + 1), j = pi[j - 1];",
      "    }",
      " ",
      "    return res;",
      "  }",
      "};"
    ],
    "description": "KMP Algorithm for String Matching"
  },
  "Z-Algorithm": {
    "prefix": "zalgo",
    "scope": "cpp",
    "body": [
      "struct ZAlgo {",
      "  vec<int> z_function(const string& s) {",
      "    int n = len(s);",
      "    vec<int> z(n);",
      "",
      "    for(int l = 0, r = 0, i = 1; i < n; i++) {",
      "      if(i < r) z[i] = min(r - i, z[i - l]);",
      "      for(; i + z[i] < n && s[z[i]] == s[i + z[i]]; z[i]++);",
      "      if(i + z[i] > r) l = i, r = i + z[i];",
      "    }",
      "    return z;",
      "  }",
      "",
      "  vec<int> match(const string& text, const string& pat) {",
      "    string s = pat + '#' + text;",
      "    vec<int> res, z = z_function(s);",
      " ",
      "    for(int m = len(pat), i = m + 1; i < len(s); i++) {",
      "      if(z[i] == m) res.eb(i - m - 1);",
      "    }",
      "    return res;",
      "  }",
      "};"
    ],
    "description": "Z-Algorithm for String Matching"
  },
  "Rolling Hash": {
    "prefix": "rollinghash",
    "scope": "cpp",
    "body": [
      "struct RollingHash {",
      "  using mint7 = ModInt<1000000007>;",
      "  using mint9 = ModInt<1000000009>;",
      "  const int BASE = 131;",
      "",
      "  vec<mint7> hash1, power1;",
      "  vec<mint9> hash2, power2;",
      "",
      "  RollingHash(const string& s) {",
      "    int n = len(s);",
      "    hash1.resize(n + 1); hash2.resize(n + 1);",
      "    power1.resize(n + 1); power2.resize(n + 1);",
      "    hash1[0] = 0; hash2[0] = 0;",
      "    power1[0] = 1; power2[0] = 1;",
      "",
      "    for(int i = 0; i < n; i++) {",
      "      hash1[i + 1] = hash1[i] * BASE + s[i];",
      "      hash2[i + 1] = hash2[i] * BASE + s[i];",
      "      power1[i + 1] = power1[i] * BASE;",
      "      power2[i + 1] = power2[i] * BASE;",
      "    }",
      "  }",
      "",
      "  pair<mint7, mint9> get(int l, int r) { // [l, r)",
      "    mint7 h1 = hash1[r] - hash1[l] * power1[r - l];",
      "    mint9 h2 = hash2[r] - hash2[l] * power2[r - l];",
      "    return {h1, h2};",
      "  }",
      "};"
    ],
    "description": "Rolling Hash for String Matching"
  },
  "Tree": {
    "prefix": "tree",
    "scope": "cpp",
    "body": [
      "struct Tree {",
      "  vvec<int> adj;",
      "  int h;",
      "  vvec<int> up;",
      "  vec<int> tin, tout;",
      "  vec<int> depth;",
      "  int timer;",
      "",
      "  Tree(int n) : adj(n), tin(n), tout(n), depth(n) {",
      "    for(h = 0; 1 << h <= n; h++);",
      "    up.resize(n, vec<int>(h, -1));",
      "  }",
      "",
      "  void add_edge(int u, int v) {",
      "    adj[u].eb(v);",
      "    adj[v].eb(u);",
      "  }",
      "",
      "  void build() {",
      "    timer = 0;",
      "    depth[0] = 0;",
      "    dfs(0);",
      "  }",
      "",
      "  void dfs(int u, int p = -1) {",
      "    tin[u] = ++timer;",
      "",
      "    up[u][0] = p;",
      "    for(int i = 1; i < h && up[u][i - 1] != -1; i++) {",
      "      up[u][i] = up[up[u][i - 1]][i - 1];",
      "    }",
      "",
      "    for(auto v : adj[u]) {",
      "      if(v == p) continue;",
      "",
      "      depth[v] = depth[u] + 1;",
      "      dfs(v, u);",
      "    }",
      "",
      "    tout[u] = ++timer;",
      "  }",
      "",
      "  int kth_ancestor(int u, int k) {",
      "    for(int i = 0; k > 0 && u != -1; i++, k >>= 1) {",
      "      if(k & 1) u = up[u][i];",
      "    }",
      "",
      "    return u == -1 ? -1 : u + 1;",
      "  }",
      "",
      "  bool is_ancestor(int u, int v) {",
      "    return tin[u] <= tin[v] && tout[u] >= tout[v];",
      "  }",
      "",
      "  int lca(int u, int v) {",
      "    if(is_ancestor(u, v)) return u;",
      "    if(is_ancestor(v, u)) return v;",
      "",
      "    for(int i = h - 1; i >= 0; i--) {",
      "      if(up[u][i] != -1 && !is_ancestor(up[u][i], v))",
      "        u = up[u][i];",
      "    }",
      "",
      "    return up[u][0];",
      "  }",
      "",
      "  int dist(int u, int v) {",
      "    return depth[u] + depth[v] - 2 * depth[lca(u, v)];",
      "  }",
      "};"
    ],
    "description": "Tree"
  },
}