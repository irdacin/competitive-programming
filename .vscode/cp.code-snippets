{
	"main": {
		"scope": "cpp",
		"prefix": "cpp-cp",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"",
			"#define int long long",
			"#define fastio ios_base::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL)",
			"#define endl '\\n'",
			"#define debug(x) cout << #x << \" => \" << x << endl",
			"",
			"template <typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& _p) {",
			"  os << _p.first << ' ' << _p.second; return os;",
			"}",
			"template <typename T> istream& operator>>(istream& is, vector<T>& _v) {",
			"  for(auto &_i : _v) { is >> _i; } return is;",
			"}",
			"template <typename T> ostream& operator<<(ostream& os, const vector<T>& _v) {",
			"  for(auto &_i : _v) { os << _i; if(&_i != &_v.back()) os << ' '; } return os;",
			"}",
			"inline void print() { cout << endl; }",
			"template <typename T = const char*, typename... U> ",
			"inline void prin(T&& A = \"\", U&&... B) { cout << A; if (sizeof...(U)) prin(B...); }",
			"template <typename T, typename... U>",
			"inline void print(T&& A, U&&... B) { prin(A); if (sizeof...(U)) prin(' '); print(B...); }",
			"template <typename T> inline void printsp(T&& A, const char* sp = \" \") { prin(A, sp); }",
			"",
			"template <typename T> struct vec : vector<T> { using vector<T>::vector; };",
			"template <typename T> struct vvec : vec<vec<T>> {",
			"  using vec<vec<T>>::vec;",
			"  vvec(int N = 0, int M = 0, const T& _init_value = T())",
			"    : vec<vec<T>>(N, vec<T>(M, _init_value)) {}",
			"};",
			"template <typename T> struct vvvec : vec<vvec<T>> {",
			"  using vec<vvec<T>>::vec;",
			"  vvvec(int N = 0, int M = 0, int K = 0, const T& _init_value = T())",
			"    : vec<vvec<T>>(N, vvec<T>(M, K, _init_value)) {}",
			"};",
			"",
			"using pii = pair<int, int>;",
			"using iii = tuple<int, int, int>;",
			"#define fi first",
			"#define se second",
			"#define eb emplace_back",
			"#define all(x) x.begin(), x.end()",
			"#define len(x) (int) x.size()",
			"",
			"const int MOD = 1e9 + 7; // 998244353;",
			"const int INF = 2e9;",
			"",
			"void solve() {",
			"  $0",
			"}",
			"",
			"signed main() {",
			"  fastio;",
			"  // #undef endl",
			"",
			"  // precompute();",
			"  // cout << fixed << setprecision(6);",
			"  // int t; cin >> t; while(t--)",
			"  solve();",
			"}",
		],
		"description": "Default cpp code for Competitive Programming"
	},
	"pbds": {
		"scope": "cpp",
		"prefix": "pbds",
		"body": [
			"#include <ext/pb_ds/assoc_container.hpp>",
			"#include <ext/pb_ds/tree_policy.hpp>",
			"using namespace __gnu_pbds;",
			"template <typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;"
		],
		"description": "PBDS cpp code"
	},
	"ModInt": {
		"prefix": "modint",
		"scope": "cpp",
		"body": [
			"template<auto M>",
			"struct ModInt {",
			"  int val;",
			"  ModInt(int _val = 0) : val(_val % M) { if(val < 0) val += M; }",
			"  operator int() const { return val; }",
			"",
			"  ModInt& operator+=(const ModInt& other) { return (val += other) >= M ? val -= M : val, *this; }",
			"  ModInt& operator-=(const ModInt& other) { return (val -= other) < 0 ? val += M : val, *this; }",
			"  ModInt& operator*=(const ModInt& other) { return (val *= other) %= M, *this; }",
			"  ModInt& operator/=(const ModInt& other) { return *this *= inv(other); }",
			"  ModInt& operator++() { return *this += 1; }",
			"  ModInt& operator--() { return *this -= 1; }",
			"  ModInt operator-() const { return ModInt() -= *this; }",
			"  ModInt operator+(const auto& other) const { return ModInt(*this) += other; }",
			"  ModInt operator-(const auto& other) const { return ModInt(*this) -= other; }",
			"  ModInt operator*(const auto& other) const { return ModInt(*this) *= other; }",
			"  ModInt operator/(const auto& other) const { return ModInt(*this) /= other; }",
			"  ModInt operator++(int32_t) { ModInt mi = *this; ++*this; return mi; }",
			"  ModInt operator--(int32_t) { ModInt mi = *this; --*this; return mi; }",
			"",
			"  friend ModInt pow(ModInt mi, int k) { ModInt r = 1; for(; k > 0; k /= 2, mi *= mi) if(k & 1) r *= mi; return r; }",
			"  static int inv(ModInt mi) { return pow(mi, M - 2); }",
			"  static int inv(int mi, int mod) { return mi == 1 ? 1 : mod - inv(mod % mi, mi) * mod / mi; } // use this for div if M is not prime",
			"",
			"  friend istream& operator>>(istream& is, ModInt& mi) { is >> mi.val; mi = ModInt(mi.val); return is; }",
			"  friend ostream& operator<<(ostream& os, const ModInt& mi) { return os << mi.val; }",
			"};",
			"",
			"using mint = ModInt<1000000007>;",
			"// using mint = ModInt<998244353>;",
			"// using mint = ModInt<Barrett{}>;"
		],
		"description": "ModInt"
	},
	"Barrett": {
		"prefix": "barrett",
		"body": [
			"struct Barrett {",
			"  using u128 = __uint128_t;",
			"  static inline u128 mod, mu;",
			"",
			"  static void set_mod(int m) { mod = m, mu = -1 / mod; }",
			"  operator int() const { return mod; }",
			"  friend auto operator%(auto x, const Barrett) { return reduce(x); }",
			"",
			"  static u128 reduce(u128 x) {",
			"    u128 a = x * uint64_t(mu);",
			"    u128 b = x * (mu >> 64);",
			"    u128 c = mu * (x >> 64);",
			"    u128 d = (x >> 64) * (mu >> 64);",
			"    u128 q = d + ((b + c + (a >> 64)) >> 64);",
			"    u128 r = x - q * mod;",
			"    if(r >= mod) r -= mod;",
			"    return r;",
			"  }",
			"};"
		],
		"description": "Barrett"
	},
	"factorial": {
		"prefix": "factorial",
		"body": [
			"const int MAXN = 1e6;",
			"mint fact[MAXN + 1];",
			"",
			"void precompute() {",
			"  fact[0] = 1;",
			"  for(int i = 1; i <= MAXN; i++) fact[i] = fact[i - 1] * i;",
			"}"
		],
		"description": "Factorial Precomputation"
	},
	"directions": {
		"scope": "cpp",
		"prefix": "directions",
		"body": [
			"vec<pii> dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}, {1, 1}, {1, -1}, {-1, 1}, {-1, -1}};",
		],
		"description": "8 directions"
	},
	"DSU": {
		"scope": "cpp",
		"prefix": "dsu",
		"body": [
			"struct DSU {",
			"\tvec<int> parent, sizes;",
			"\tDSU(int n) : parent(n), sizes(n, 1) {",
			"\t\tiota(all(parent), 0);",
			"\t}",
			"",
			"\tint find(int u) {",
			"\t\treturn u == parent[u] ? u : parent[u] = find(parent[u]);",
			"\t}",
			"",
			"\tbool unite(int u, int v) {",
			"\t\tu = find(u), v = find(v);",
			"\t\tif(u == v) return false;",
			"\t\t",
			"\t\tif(sizes[u] < sizes[v]) swap(u, v);",
			"\t\tsizes[u] += sizes[v];",
			"\t\tparent[v] = u;",
			"\t\treturn true;",
			"\t}",
			"};"
		],
		"description": "DSU"
	},
	"sparse-table": {
		"scope": "cpp",
		"prefix": "sparsetable",
		"body": [
			"struct SparseTable {",
			"  int n;",
			"  vec<int> lg;",
			"  vvec<int> table;",
			"",
			"  SparseTable(vec<int> v) : n(len(v)) {",
			"    build(v);",
			"  }",
			"",
			"  void build(vec<int> v) {",
			"    lg.resize(n + 1);",
			"    lg[1] = 0;",
			"    for(int i = 2; i <= n; i++) lg[i] = lg[i / 2] + 1;",
			"    ",
			"    table.resize(lg[n] + 1, vec<int>(n));",
			"    for(int i = 0; i < n; i++) table[0][i] = v[i];",
			"    for(int j = 1; j <= lg[n]; j++) {",
			"      for(int i = 0; i + (1 << j) <= n; i++) {",
			"        table[j][i] = merge(table[j - 1][i], table[j - 1][i + (1 << (j - 1))]);",
			"      }",
			"    }",
			"  }",
			"",
			"  int merge(int left, int right) {",
			"    return min(left, right);",
			"  }",
			"",
			"  int query(int l, int r) {",
			"    l--, r--;",
			"    int k = lg[r - l + 1];",
			"    // return merge(table[k][l], table[k][r - (1 << k) + 1])",
			"",
			"    int res = INF;",
			"    for(int j = k; j >= 0; j--) {",
			"      if((1 << j) <= r - l + 1) {",
			"        res = merge(res, table[j][l]);",
			"        l += 1 << j;",
			"      }",
			"    }",
			"",
			"    return res;",
			"  }",
			"};"
		],
		"description": "Sparse Table",
	},
	"fenwick-tree": {
		"scope": "cpp",
		"prefix": "fenwicktree",
		"body": [
			"struct FenwickTree {",
			"  int n;",
			"  vec<int> bit;",
			"",
			"  FenwickTree(int _n) : n(_n + 1) {",
			"    bit.resize(n);",
			"  }",
			"",
			"  FenwickTree(vec<int> v) : n(len(v) + 1) {",
			"    bit.resize(n);",
			"    for(int i = 1; i < n; i++)",
			"      update(i, v[i - 1]);",
			"  }",
			"",
			"  void set(int pos, int val) {",
			"    int x = query(pos, pos);",
			"    update(pos, -x);",
			"    update(pos, val);",
			"  }",
			"",
			"  void update(int pos, int val) {    ",
			"    for(; pos <= n; pos += pos & -pos) ",
			"      bit[pos] += val;",
			"  }",
			"",
			"  int query(int pos) {",
			"    int res = 0;",
			"    for(; pos > 0; pos -= pos & -pos)",
			"      res += bit[pos];",
			"    return res;",
			"  }",
			"",
			"  void update(int l, int r, int val) {",
			"    update(l, val);",
			"    update(r + 1, -val);",
			"  }",
			"",
			"  int query(int l, int r) {",
			"    return query(r) - query(l - 1);",
			"  }",
			"};"
		],
		"description": "Fenwick Tree Code"
	},
	"segment-tree": {
		"scope": "cpp",
		"prefix": "segtree",
		"body": [
			"struct SegmentTree {",
			"  #define m ((l + r) >> 1)",
			"  #define lc (id << 1)",
			"  #define rc (lc | 1)",
			"",
			"  struct node {",
			"    int val;",
			"    node(int _val = 0) : val(_val) {}",
			"  };",
			"",
			"  int n;",
			"  vec<int> v;",
			"  vec<node> tree;",
			"  ",
			"  SegmentTree(int _n) : n(_n) {",
			"    int sz = 1;",
			"    for(; sz < n; sz <<= 1);",
			"    tree.resize(sz << 1);",
			"  }",
			"  ",
			"  SegmentTree(vec<int> _v) : n(len(_v)), v(_v) {",
			"    int sz = 1;",
			"    for(; sz < n; sz <<= 1);",
			"    tree.resize(sz << 1);",
			"    build(0, n - 1, 1);",
			"  }",
			"",
			"  node merge(node left, node right) {",
			"    return left + right;",
			"  }",
			"",
			"  void build(int l, int r, int id) {",
			"    if(l == r) {",
			"      tree[id] = node(v[l]);",
			"      return;",
			"    }",
			"    ",
			"    build(l, m, lc);",
			"    build(m + 1, r, rc);",
			"    tree[id] = merge(tree[lc], tree[rc]);",
			"  }",
			"  ",
			"  void update(int l, int r, int id, int pos, int val) {",
			"    if(l == r){",
			"      tree[id] = node(val);",
			"      return;",
			"    }",
			"",
			"    if(pos <= m) update(l, m, lc, pos, val);",
			"    else update(m + 1, r, rc, pos, val);",
			"    tree[id] = merge(tree[lc], tree[rc]);",
			"  }",
			"",
			"  node query(int l, int r, int id, int pl, int pr) {",
			"    if(l > pr || r < pl) return node();",
			"    if(pl <= l && r <= pr){",
			"      return tree[id];",
			"    }",
			"",
			"    return merge(query(l, m, lc, pl, pr), query(m + 1, r, rc, pl, pr));",
			"  }",
			"",
			"  void update(int pos, int val) {",
			"    update(0, n - 1, 1, pos, val);",
			"  }",
			"",
			"  int query(int l, int r) {",
			"    return query(0, n - 1, 1, l, r);",
			"  }",
			"",
			"  #undef m",
			"  #undef lc",
			"  #undef rc",
			"};"
		],
		"description": "Segment Tree Code"
	},
	"segment-tree-lazy": {
		"scope": "cpp",
		"prefix": "segtreelazy",
		"body": [
			"struct SegmentTree {",
			"  #define m ((l + r) >> 1)",
			"  #define lc (id << 1)",
			"  #define rc (lc | 1)",
			"",
			"  struct node {",
			"    int val;",
			"    node(int _val = 0) : val(_val) {}",
			"    // node &operator+=(int other){ return val += other, *this; }",
			"  };",
			"",
			"  int n;",
			"  vec<int> v;",
			"  vec<node> tree;",
			"  vec<int> lazy;",
			"  ",
			"  SegmentTree(int _n) : n(_n) {",
			"    int sz = 1;",
			"    for(; sz < n; sz <<= 1);",
			"    tree.resize(sz << 1);",
			"    lazy.resize(sz << 1);",
			"  }",
			"  ",
			"  SegmentTree(vec<int> _v) : n(len(_v)), v(_v) {",
			"    int sz = 1;",
			"    for(; sz < n; sz <<= 1);",
			"    tree.resize(sz << 1);",
			"    lazy.resize(sz << 1);",
			"    build(0, n - 1, 1);",
			"  }",
			"",
			"  node merge(node left, node right) {",
			"    return left + right;",
			"  }",
			"",
			"  void build(int l, int r, int id) {",
			"    if(l == r) {",
			"      tree[id] = node(v[l]);",
			"      return;",
			"    }",
			"",
			"    build(l, m, lc);",
			"    build(m + 1, r, rc);",
			"    tree[id] = merge(tree[lc], tree[rc]);",
			"  }",
			"",
			"  void propagate(int l, int r, int id) {",
			"    if(lazy[id]) {",
			"      // tree[id] += (r - l + 1) * lazy[id];",
			"      if(l < r) {",
			"        lazy[lc] += lazy[id];",
			"        lazy[rc] += lazy[id];",
			"      }",
			"",
			"      lazy[id] = 0;",
			"    }",
			"  }",
			"",
			"  void update(int l, int r, int id, int pl, int pr, int val) {",
			"    propagate(l, r, id);",
			"",
			"    if(l > pr || r < pl) return;",
			"    if(pl <= l && r <= pr) {",
			"      lazy[id] = val;",
			"      propagate(l, r, id);",
			"      return;",
			"    }",
			"",
			"    update(l, m, lc, pl, pr, val);",
			"    update(m + 1, r, rc, pl, pr, val);",
			"    tree[id] = merge(tree[lc], tree[rc]);",
			"  }",
			"",
			"  node query(int l, int r, int id, int pos) {",
			"    propagate(l, r, id);",
			"",
			"    if(l == r) {",
			"      return tree[id];",
			"    }",
			"",
			"    if(pos <= m) return query(l, m, lc, pos);",
			"    else return query(m + 1, r, rc, pos);",
			"  }",
			"",
			"  node query(int l, int r, int id, int pl, int pr) {",
			"    propagate(l, r, id);",
			"",
			"    if(l > pr || r < pl) return node();",
			"    if(pl <= l && r <= pr) {",
			"      return tree[id];",
			"    }",
			"",
			"    return merge(query(l, m, lc, pl, pr), query(m + 1, r, rc, pl, pr));",
			"  }",
			"",
			"  void update(int l, int r, int val) {",
			"    update(0, n - 1, 1, l, r, val);",
			"  }",
			"",
			"  int query(int pos) {",
			"    return query(0, n - 1, 1, pos);",
			"  }",
			"",
			"  int query(int l, int r) {",
			"    return query(0, n - 1, 1, l, r);",
			"  }",
			"",
			"  #undef m",
			"  #undef lc",
			"  #undef rc",
			"};"
		],
		"description": "Lazy Segment Tree Code"
	},
	"Line Intersection": {
		"prefix": "inter",
		"scope": "cpp",
		"body": [
			"struct point {",
			"  int x, y;",
			"  point(int _x = 0, int _y = 0) : x(_x), y(_y) {}",
			"  point operator+(const point& p) const { return point(x + p.x, y + p.y); }",
			"  point operator-(const point& p) const { return point(x - p.x, y - p.y); }",
			"  ",
			"  int cross(const point& p) const { return x * p.y - y * p.x; }",
			"  int cross(const point& p, const point& q) const { return (p - *this).cross(q - *this); }",
			"  double dist(const point& p) const { return sqrt((x - p.x) * (x - p.x) + (y - p.y) * (y - p.y)); }",
			"",
			"  friend bool intersect(point p, point q, point r, point s) {",
			"    auto sign = [](int x) { return x >= 0 ? x > 0 : -1; };",
			"    auto overlap = [](int a, int b, int c, int d) {",
			"      return max(min(a, b), min(c, d)) <= min(max(a, b), max(c, d));",
			"    };",
			"",
			"    if(sign(p.cross(r, s)) == 0 && sign(r.cross(p, q)) == 0)",
			"      return overlap(p.x, q.x, r.x, s.x) && overlap(p.y, q.y, r.y, s.y);",
			"",
			"    return sign(p.cross(r, s)) != sign(q.cross(r, s)) && sign(r.cross(p, q)) != sign(s.cross(p, q));",
			"  }",
			"",
			"  bool operator==(const point& p) const { return x == p.x && y == p.y; }",
			"  bool operator!=(const point& p) const { return x != p.x || y != p.y; }",
			"  friend istream& operator>>(istream& is, point& p) { return is >> p.x >> p.y; }",
			"  friend ostream& operator<<(ostream& os, const point& p) { return os << p.x << ' ' << p.y << endl; }",
			"};"
		],
		"description": "Line Intersection"
	},
	"Matrix Eksponensial": {
		"prefix": "matrix",
		"scope": "cpp",
		"body": [
			"struct matrix : vvec<mint> {",
			"  using vvec<mint>::vvec;",
			"",
			"  matrix& operator*=(const matrix& other) {",
			"    int n = len((*this));",
			"    int m = len((*this)[0]);",
			"    assert(m == len(other));",
			"",
			"    matrix res(n, m);",
			"    for(int i = 0; i < n; i++)",
			"      for(int j = 0; j < len(other[0]); j++)",
			"        for(int k = 0; k < m; k++)",
			"          res[i][j] += (*this)[i][k] * other[k][j];",
			"    return *this = res;",
			"  }",
			"",
			"  matrix operator*(const matrix& other) const { ",
			"    return matrix(*this) *= other; ",
			"  }",
			"",
			" friend matrix pow(matrix mat, int k) {",
			"    int n = len(mat);",
			"    assert(n == len(mat[0]));",
			"",
			"    matrix res(n, n);",
			"    for(int i = 0; i < n; i++) res[i][i] = 1;",
			"    for(; k > 0; k /= 2, mat *= mat) if(k & 1) res *= mat;",
			"    return res;",
			"  }",
			"};"
		],
		"description": "Matrix Eksponensial"
	},
}