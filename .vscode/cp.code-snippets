{
  "main": {
    "scope": "cpp",
    "prefix": "cpp-cp",
    "body": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "",
      "#define int long long",
      "#define fastio ios_base::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL)",
      "#define endl '\\n'",
      "#define debug(x) cout << #x << \" => \" << (x) << endl",
      " ",
      "template <typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& _p) { ",
      "  os << \"(\" << _p.first << \", \" << _p.second << \")\"; return os; ",
      "}",
      "template <typename T> istream& operator>>(istream& is, vector<T>& _v) {",
      "  for (auto& _x : _v) { is >> _x; } return is;",
      "}",
      "template <typename Ch, typename Tr, typename Container>",
      "basic_ostream<Ch, Tr>& operator<<(basic_ostream<Ch, Tr>& os, const Container& _c) {",
      "  int _i = 0; os << \"{ \"; for (const auto& _x : _c) { os << (_i++ ? \", \" : \"\") << _x; }",
      "  return os << \" }\";",
      "}",
      "inline void print() { cout << endl; }",
      "template <typename T = const char*, typename... U> ",
      "inline void prin(T&& A = \"\", U&&... B) { cout << A; if (sizeof...(U)) prin(B...); }",
      "template <typename T, typename... U>",
      "inline void print(T&& A, U&&... B) { prin(A); if (sizeof...(U)) prin(' '); print(B...); }",
      "template <typename T> inline void printsp(T&& A, char sp = ' ') { prin(A, sp); }",
      "",
      "template <typename T> using vec = vector<T>;",
      "template <typename T> struct vvec : vec<vec<T>> {",
      "  using vec<vec<T>>::vec;",
      "  vvec(int N = 0, int M = 0, const T& _init_value = T())",
      "    : vec<vec<T>>(N, vec<T>(M, _init_value)) {}",
      "};",
      "template <typename T> struct vvvec : vec<vvec<T>> {",
      "  using vec<vvec<T>>::vec;",
      "  vvvec(int N = 0, int M = 0, int K = 0, const T& _init_value = T())",
      "    : vec<vvec<T>>(N, vvec<T>(M, K, _init_value)) {}",
      "};",
      "",
      "using pii = pair<int, int>;",
      "using iii = tuple<int, int, int>;",
      "#define fi first",
      "#define se second",
      "#define eb emplace_back",
      "#define all(x) (x).begin(), (x).end()",
      "#define len(x) (int)(x).size()",
      "",
      "const int MOD = 1e9 + 7; // 998244353;",
      "const int INF = 2e9;",
      "",
      "void solve() {",
      "  $0",
      "}",
      "",
      "signed main() {",
      "  fastio;",
      "  // #undef endl",
      "",
      "  // precompute();",
      "  // cout << fixed << setprecision(6);",
      "  // int t; cin >> t; while(t--)",
      "  solve();",
      "}",
    ],
    "description": "Default cpp code for Competitive Programming"
  },
  "test-case": {
    "prefix": "tc",
    "scope": "cpp",
    "body": [
      "int t; cin >> t; for(int tc = 1; tc <= t; tc++)",
      "prin(\"Case #\", tc, \": \"),"
    ],
    "description": "Test Case"
  },
  "pbds": {
    "scope": "cpp",
    "prefix": "pbds",
    "body": [
      "#include <ext/pb_ds/assoc_container.hpp>",
      "#include <ext/pb_ds/tree_policy.hpp>",
      "using namespace __gnu_pbds;",
      "template <typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;"
    ],
    "description": "PBDS cpp code"
  },
  "ModInt": {
    "prefix": "modint",
    "scope": "cpp",
    "body": [
      "template<auto M>",
      "struct ModInt {",
      "  int val;",
      "  ModInt(int _val = 0) : val(_val % M) { if(val < 0) val += M; }",
      "  explicit operator int() const { return val; }",
      " ",
      "  ModInt& operator+=(const ModInt& other) { return (val += other.val) >= M ? val -= M : val, *this; }",
      "  ModInt& operator-=(const ModInt& other) { return (val -= other.val) < 0 ? val += M : val, *this; }",
      "  ModInt& operator*=(const ModInt& other) { return (val *= other.val) %= M, *this; }",
      "  ModInt& operator/=(const ModInt& other) { return *this *= inv(other.val); }",
      "  ModInt& operator++() { return *this += 1; }",
      "  ModInt& operator--() { return *this -= 1; }",
      "  ModInt operator++(int32_t) { ModInt mi = *this; ++*this; return mi; }",
      "  ModInt operator--(int32_t) { ModInt mi = *this; --*this; return mi; }",
      "  ModInt operator+() const { return *this; }",
      "  ModInt operator-() const { return ModInt() -= *this; }",
      "  friend ModInt operator+(const ModInt& lhs, const ModInt& rhs) { return ModInt(lhs) += rhs; }",
      "  friend ModInt operator-(const ModInt& lhs, const ModInt& rhs) { return ModInt(lhs) -= rhs; }",
      "  friend ModInt operator*(const ModInt& lhs, const ModInt& rhs) { return ModInt(lhs) *= rhs; }",
      "  friend ModInt operator/(const ModInt& lhs, const ModInt& rhs) { return ModInt(lhs) /= rhs; }",
      " ",
      "  friend ModInt pow(ModInt mi, int k) { ModInt r = 1; for(; k > 0; k /= 2, mi *= mi) if(k & 1) r *= mi; return r; }",
      "  static int inv(ModInt mi) { return (int) pow(mi, M - 2); }",
      "  static int inv(int mi, int mod) { return mi == 1 ? 1 : mod - inv(mod % mi, mi) * mod / mi; } // use this for div if M is not prime",
      " ",
      "  bool operator==(const ModInt& other) const { return val == other.val; }",
      "  bool operator!=(const ModInt& other) const { return val != other.val; }",
      "  friend istream& operator>>(istream& is, ModInt& mi) { is >> mi.val; mi = ModInt(mi.val); return is; }",
      "  friend ostream& operator<<(ostream& os, const ModInt& mi) { return os << mi.val; }",
      "};",
      "",
      "using mint = ModInt<1000000007>;",
      "// using mint = ModInt<998244353>;",
      "// using mint = ModInt<Barrett{}>;"
    ],
    "description": "ModInt"
  },
  "Barrett": {
    "prefix": "barrett",
    "body": [
      "struct Barrett {",
      "  using u128 = __uint128_t;",
      "  static inline u128 mod, mu;",
      "",
      "  static void set_mod(int m) { mod = m, mu = -1 / mod; }",
      "  operator int() const { return mod; }",
      "  friend auto operator%(auto x, const Barrett) { return reduce(x); }",
      "",
      "  static u128 reduce(u128 x) {",
      "    u128 a = x * uint64_t(mu);",
      "    u128 b = x * (mu >> 64);",
      "    u128 c = mu * (x >> 64);",
      "    u128 d = (x >> 64) * (mu >> 64);",
      "    u128 q = d + ((b + c + (a >> 64)) >> 64);",
      "    u128 r = x - q * mod;",
      "    if(r >= mod) r -= mod;",
      "    return r;",
      "  }",
      "};"
    ],
    "description": "Barrett"
  },
  "factorial": {
    "prefix": "factorial",
    "body": [
      "const int MAXN = 1e6;",
      "mint fact[MAXN + 1];",
      "",
      "void precompute() {",
      "  fact[0] = 1;",
      "  for(int i = 1; i <= MAXN; i++) fact[i] = fact[i - 1] * i;",
      "}",
      "",
      "mint C(int n, int k) {",
      "  if(k > n) return 0;",
      "  return fact[n] / (fact[k] * fact[n - k]);",
      "}",
    ],
    "description": "Factorial Precomputation"
  },
  "directions": {
    "scope": "cpp",
    "prefix": "directions",
    "body": [
      "vec<pii> dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}, {1, 1}, {1, -1}, {-1, 1}, {-1, -1}};",
    ],
    "description": "8 directions"
  },
  "Print Vector": {
    "prefix": "printv",
    "scope": "cpp",
    "body": [
      "for(auto &x : ${0:ans}) prin(x, \" \\n\"[&x == &${0:ans}.back()]);"
    ],
    "description": "Print Vector"
  },
  "DSU": {
    "scope": "cpp",
    "prefix": "dsu",
    "body": [
      "struct DSU {",
      "\tvec<int> parent, sizes;",
      "\tDSU(int n) : parent(n), sizes(n, 1) {",
      "\t\tiota(all(parent), 0);",
      "\t}",
      "",
      "\tint find(int u) {",
      "\t\treturn u == parent[u] ? u : parent[u] = find(parent[u]);",
      "\t}",
      "",
      "\tbool unite(int u, int v) {",
      "\t\tu = find(u), v = find(v);",
      "\t\tif(u == v) return false;",
      "\t\t",
      "\t\tif(sizes[u] < sizes[v]) swap(u, v);",
      "\t\tsizes[u] += sizes[v];",
      "\t\tparent[v] = u;",
      "\t\treturn true;",
      "\t}",
      "};"
    ],
    "description": "DSU"
  },
  "sparse-table": {
    "scope": "cpp",
    "prefix": "sparsetable",
    "body": [
      "struct SparseTable {",
      "  int n;",
      "  vec<int> lg;",
      "  vvec<int> table;",
      "",
      "  SparseTable(vec<int> v) : n(len(v)) {",
      "    build(v);",
      "  }",
      "",
      "  void build(vec<int> v) {",
      "    lg.resize(n + 1);",
      "    lg[1] = 0;",
      "    for(int i = 2; i <= n; i++) lg[i] = lg[i / 2] + 1;",
      "    ",
      "    table.resize(lg[n] + 1, vec<int>(n));",
      "    for(int i = 0; i < n; i++) table[0][i] = v[i];",
      "    for(int j = 1; j <= lg[n]; j++) {",
      "      for(int i = 0; i + (1 << j) <= n; i++) {",
      "        table[j][i] = merge(table[j - 1][i], table[j - 1][i + (1 << (j - 1))]);",
      "      }",
      "    }",
      "  }",
      "",
      "  int merge(int left, int right) {",
      "    return min(left, right);",
      "  }",
      "",
      "  int query(int l, int r) {",
      "    l--, r--;",
      "    int k = lg[r - l + 1];",
      "    // return merge(table[k][l], table[k][r - (1 << k) + 1])",
      "",
      "    int res = INF;",
      "    for(int j = k; j >= 0; j--) {",
      "      if((1 << j) <= r - l + 1) {",
      "        res = merge(res, table[j][l]);",
      "        l += 1 << j;",
      "      }",
      "    }",
      "",
      "    return res;",
      "  }",
      "};"
    ],
    "description": "Sparse Table",
  },
  "fenwick-tree": {
    "scope": "cpp",
    "prefix": "fenwicktree",
    "body": [
      "struct FenwickTree {",
      "  int n;",
      "  vec<int> bit;",
      "",
      "  FenwickTree(int _n) : n(_n + 1) {",
      "    bit.resize(n);",
      "  }",
      "",
      "  FenwickTree(vec<int> v) : n(len(v) + 1) {",
      "    bit.resize(n);",
      "    for(int i = 1; i < n; i++)",
      "      update(i, v[i - 1]);",
      "  }",
      "",
      "  void set(int pos, int val) {",
      "    int x = query(pos, pos);",
      "    update(pos, -x);",
      "    update(pos, val);",
      "  }",
      "",
      "  void update(int pos, int val) {    ",
      "    for(; pos <= n; pos += pos & -pos) ",
      "      bit[pos] += val;",
      "  }",
      "",
      "  int query(int pos) {",
      "    int res = 0;",
      "    for(; pos > 0; pos -= pos & -pos)",
      "      res += bit[pos];",
      "    return res;",
      "  }",
      "",
      "  void update(int l, int r, int val) {",
      "    update(l, val);",
      "    update(r + 1, -val);",
      "  }",
      "",
      "  int query(int l, int r) {",
      "    return query(r) - query(l - 1);",
      "  }",
      "};"
    ],
    "description": "Fenwick Tree Code"
  },
  "segment-tree": {
    "scope": "cpp",
    "prefix": "segtree",
    "body": [
      "struct SegmentTree {",
      "  #define m ((l + r) >> 1)",
      "  #define lc (id << 1)",
      "  #define rc (lc | 1)",
      "",
      "  struct node {",
      "    int val;",
      "    node(int _val = 0) : val(_val) {}",
      "  };",
      "",
      "  int n;",
      "  vec<int> v;",
      "  vec<node> tree;",
      "  ",
      "  SegmentTree(int _n) : n(_n) {",
      "    int sz = 1;",
      "    for(; sz < n; sz <<= 1);",
      "    tree.resize(sz << 1);",
      "  }",
      "  ",
      "  SegmentTree(vec<int> _v) : n(len(_v)), v(_v) {",
      "    int sz = 1;",
      "    for(; sz < n; sz <<= 1);",
      "    tree.resize(sz << 1);",
      "    build(0, n - 1, 1);",
      "  }",
      "",
      "  node merge(node left, node right) {",
      "    return left + right;",
      "  }",
      "",
      "  void build(int l, int r, int id) {",
      "    if(l == r) {",
      "      tree[id] = node(v[l]);",
      "      return;",
      "    }",
      "    ",
      "    build(l, m, lc);",
      "    build(m + 1, r, rc);",
      "    tree[id] = merge(tree[lc], tree[rc]);",
      "  }",
      "  ",
      "  void update(int l, int r, int id, int pos, int val) {",
      "    if(l == r){",
      "      tree[id] = node(val);",
      "      return;",
      "    }",
      "",
      "    if(pos <= m) update(l, m, lc, pos, val);",
      "    else update(m + 1, r, rc, pos, val);",
      "    tree[id] = merge(tree[lc], tree[rc]);",
      "  }",
      "",
      "  node query(int l, int r, int id, int pl, int pr) {",
      "    if(l > pr || r < pl) return node();",
      "    if(pl <= l && r <= pr){",
      "      return tree[id];",
      "    }",
      "",
      "    return merge(query(l, m, lc, pl, pr), query(m + 1, r, rc, pl, pr));",
      "  }",
      "",
      "  void update(int pos, int val) {",
      "    update(0, n - 1, 1, pos, val);",
      "  }",
      "",
      "  int query(int l, int r) {",
      "    return query(0, n - 1, 1, l, r);",
      "  }",
      "",
      "  #undef m",
      "  #undef lc",
      "  #undef rc",
      "};"
    ],
    "description": "Segment Tree Code"
  },
  "segment-tree-lazy": {
    "scope": "cpp",
    "prefix": "segtreelazy",
    "body": [
      "struct SegmentTree {",
      "  #define m ((l + r) >> 1)",
      "  #define lc (id << 1)",
      "  #define rc (lc | 1)",
      "",
      "  struct node {",
      "    int val;",
      "    node(int _val = 0) : val(_val) {}",
      "    // node &operator+=(int other){ return val += other, *this; }",
      "  };",
      "",
      "  int n;",
      "  vec<int> v;",
      "  vec<node> tree;",
      "  vec<int> lazy;",
      "  ",
      "  SegmentTree(int _n) : n(_n) {",
      "    int sz = 1;",
      "    for(; sz < n; sz <<= 1);",
      "    tree.resize(sz << 1);",
      "    lazy.resize(sz << 1);",
      "  }",
      "  ",
      "  SegmentTree(vec<int> _v) : n(len(_v)), v(_v) {",
      "    int sz = 1;",
      "    for(; sz < n; sz <<= 1);",
      "    tree.resize(sz << 1);",
      "    lazy.resize(sz << 1);",
      "    build(0, n - 1, 1);",
      "  }",
      "",
      "  node merge(node left, node right) {",
      "    return left + right;",
      "  }",
      "",
      "  void build(int l, int r, int id) {",
      "    if(l == r) {",
      "      tree[id] = node(v[l]);",
      "      return;",
      "    }",
      "",
      "    build(l, m, lc);",
      "    build(m + 1, r, rc);",
      "    tree[id] = merge(tree[lc], tree[rc]);",
      "  }",
      "",
      "  void propagate(int l, int r, int id) {",
      "    if(lazy[id]) {",
      "      // tree[id] += (r - l + 1) * lazy[id];",
      "      if(l < r) {",
      "        lazy[lc] += lazy[id];",
      "        lazy[rc] += lazy[id];",
      "      }",
      "",
      "      lazy[id] = 0;",
      "    }",
      "  }",
      "",
      "  void update(int l, int r, int id, int pl, int pr, int val) {",
      "    propagate(l, r, id);",
      "",
      "    if(l > pr || r < pl) return;",
      "    if(pl <= l && r <= pr) {",
      "      lazy[id] = val;",
      "      propagate(l, r, id);",
      "      return;",
      "    }",
      "",
      "    update(l, m, lc, pl, pr, val);",
      "    update(m + 1, r, rc, pl, pr, val);",
      "    tree[id] = merge(tree[lc], tree[rc]);",
      "  }",
      "",
      "  node query(int l, int r, int id, int pos) {",
      "    propagate(l, r, id);",
      "",
      "    if(l == r) {",
      "      return tree[id];",
      "    }",
      "",
      "    if(pos <= m) return query(l, m, lc, pos);",
      "    else return query(m + 1, r, rc, pos);",
      "  }",
      "",
      "  node query(int l, int r, int id, int pl, int pr) {",
      "    propagate(l, r, id);",
      "",
      "    if(l > pr || r < pl) return node();",
      "    if(pl <= l && r <= pr) {",
      "      return tree[id];",
      "    }",
      "",
      "    return merge(query(l, m, lc, pl, pr), query(m + 1, r, rc, pl, pr));",
      "  }",
      "",
      "  void update(int l, int r, int val) {",
      "    update(0, n - 1, 1, l, r, val);",
      "  }",
      "",
      "  int query(int pos) {",
      "    return query(0, n - 1, 1, pos);",
      "  }",
      "",
      "  int query(int l, int r) {",
      "    return query(0, n - 1, 1, l, r);",
      "  }",
      "",
      "  #undef m",
      "  #undef lc",
      "  #undef rc",
      "};"
    ],
    "description": "Lazy Segment Tree Code"
  },
  "Line Intersection": {
    "prefix": "inter",
    "scope": "cpp",
    "body": [
      "struct point {",
      "  int x, y;",
      "  point(int _x = 0, int _y = 0) : x(_x), y(_y) {}",
      "  point operator+(const point& p) const { return point(x + p.x, y + p.y); }",
      "  point operator-(const point& p) const { return point(x - p.x, y - p.y); }",
      "  ",
      "  int cross(const point& p) const { return x * p.y - y * p.x; }",
      "  int cross(const point& p, const point& q) const { return (p - *this).cross(q - *this); }",
      "  double dist(const point& p) const { return sqrt((x - p.x) * (x - p.x) + (y - p.y) * (y - p.y)); }",
      "",
      "  friend bool intersect(point p, point q, point r, point s) {",
      "    auto sign = [](int x) { return x >= 0 ? x > 0 : -1; };",
      "    auto overlap = [](int a, int b, int c, int d) {",
      "      return max(min(a, b), min(c, d)) <= min(max(a, b), max(c, d));",
      "    };",
      "",
      "    if(sign(p.cross(r, s)) == 0 && sign(r.cross(p, q)) == 0)",
      "      return overlap(p.x, q.x, r.x, s.x) && overlap(p.y, q.y, r.y, s.y);",
      "",
      "    return sign(p.cross(r, s)) != sign(q.cross(r, s)) && sign(r.cross(p, q)) != sign(s.cross(p, q));",
      "  }",
      "",
      "  bool operator==(const point& p) const { return x == p.x && y == p.y; }",
      "  bool operator!=(const point& p) const { return x != p.x || y != p.y; }",
      "  friend istream& operator>>(istream& is, point& p) { return is >> p.x >> p.y; }",
      "  friend ostream& operator<<(ostream& os, const point& p) { return os << p.x << ' ' << p.y << endl; }",
      "};"
    ],
    "description": "Line Intersection"
  },
  "Matrix Eksponensial": {
    "prefix": "matrix",
    "scope": "cpp",
    "body": [
      "struct matrix : vvec<mint> {",
      "  using vvec<mint>::vvec;",
      "",
      "  matrix& operator*=(const matrix& other) {",
      "    int n = len((*this));",
      "    int m = len((*this)[0]);",
      "    assert(m == len(other));",
      "",
      "    matrix res(n, m);",
      "    for(int i = 0; i < n; i++)",
      "      for(int j = 0; j < len(other[0]); j++)",
      "        for(int k = 0; k < m; k++)",
      "          res[i][j] += (*this)[i][k] * other[k][j];",
      "    return *this = res;",
      "  }",
      "",
      "  matrix operator*(const matrix& other) const { ",
      "    return matrix(*this) *= other; ",
      "  }",
      "",
      " friend matrix pow(matrix mat, int k) {",
      "    int n = len(mat);",
      "    assert(n == len(mat[0]));",
      "",
      "    matrix res(n, n);",
      "    for(int i = 0; i < n; i++) res[i][i] = 1;",
      "    for(; k > 0; k /= 2, mat *= mat) if(k & 1) res *= mat;",
      "    return res;",
      "  }",
      "};"
    ],
    "description": "Matrix Eksponensial"
  },
  "Sieve of Eratosthenes": {
    "prefix": "sieve",
    "scope": "cpp",
    "body": [
      "const int MAXN = 2e5;",
      "bool isPrime[MAXN + 1];",
      "vec<int> primes;",
      "",
      "void precompute() {",
      "  memset(isPrime, true, sizeof(isPrime));",
      "  isPrime[0] = isPrime[1] = false;",
      "  for(int i = 2; i <= MAXN; i++) {",
      "    if(isPrime[i]) {",
      "      primes.eb(i);",
      "      for(int j = i * i; j <= MAXN; j += i) {",
      "        isPrime[j] = false;",
      "      }",
      "    }",
      "  }",
      "}"
    ],
    "description": "Sieve of Eratosthenes Precomputation"
  },
  "Small Prime Factor": {
    "prefix": "spf",
    "body": [
      "const int MAXN = 2e5;",
      "int spf[MAXN + 1];",
      "",
      "void precompute() {",
      "  iota(spf, spf + MAXN + 1, 0);",
      "  for(int i = 2; i * i <= MAXN; i++) {",
      "    if(spf[i] == i) {",
      "      for(int j = i * i; j <= MAXN; j += i) {",
      "        if(spf[j] == j) spf[j] = i;",
      "      }",
      "    }",
      "  }",
      "}"
    ],
    "description": "Small Prime Factor Precomputation"
  },
}